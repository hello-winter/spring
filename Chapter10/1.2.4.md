## 1.2.4 프로퍼티 값 설정 방법
- DI를 통해 다른 빈 오브젝트 레퍼런스 또는 단순 값을 주입할 수 있다. 
- 보통 싱글톤은 동시성 문제 때문에 필드 값을 수정하지 않는다.
### 메타정보 종류에 따른 값 설정 방법 4가지
#### XML: <property>와 전용 태그
- ref 또는 property로 주입하는데 property가 String이 아닐 경우에는 적절한 변환이 필요하다.
#### 애노테이션: @Value
- 환경에 따라 외부에서 주입되어야하는 값 또는 그 이외에 파일 경로처럼 환경에 의존적인 정보나 작업에 대한 타임아웃처럼 상황에 달라질 수 있는 값을 유동적으로 설정해주기 위해 사용된다.
```
@Value("Everyone")
```
은 
```
<property .. value="Everyone" />
```
과 같다.
#### 자바 코드: @Value
- @Configuration과 @Bean을 사용하는 경우에도 프로퍼티 값을 분리할 필요가 있는데 다음과 같이 사용하면 된다.
```
@Configuration
public class Config {
  @Value("${database.username}")
  private String name;

  @Bean
  public Hello hello() {
  Hello hello = new Hello();
    hello.setName(this.name);
    return hello;
  }
}
```
```
@Bean
public Hello hello(@Value("${database.username}") String name) {
  Hello hello = new Hello():
  hello.setName(name);
  return hello;
}
```
### PropertyEditor와 ConversionService
- XML의 value 애트리뷰트나 @Value의 엘리먼트는 스트링 값이여서 변환이 필요할 수 있다.
- 기본으로 사용되는 타입 변환기는 PropertyEditor이라는 java.beans의 인터페이스를 구현한 것이며 변환 가능한 타입들은 다음과 같다.
#### 기본 타입
- boolean, Boolean, byte, Byte, short, Short, int, Integer, long, Long, float, Float, double, Double, BigDecimal, BigInteger, char, Character, String
- 주입 값은 항상 스트링 값이여야 한다.
- 예제)

```
boolean flag;
public void setflag(boolean flag) { this.flag = flag; }
```
```
<property name="flag" value="true" />
```
#### 배열
- byte[], char[], short[], int[], long[]
- 예제) 
```
@Value("1,2,3,4") int[] intarr;
```
#### 기타
- Charset, Class, Currency, File, InputStream, Locale, Pattern, Resource, Timezone, URI/URL 과 같은 다양한 포맷 변환이 가능하다. 
- 자세한 사용법은 원하는 포멧 타입 뒤에 Editor라고 붙여주고 그에 대한 스프링 API를 찾아보면 된다.
- 이 외에도 추가적으로 커스텀 변환을 원하는 경우 PropertyEditor라는 인터페이스를 구현해서 이용하면 된다. 하지만 이보다는 사용되고 있는 다른 오브젝트 빈을 등록하여 DI 받아서 사용하는게 낫다.

- 스프링 3.0에서부터는 자바빈을 차용해서 사용해오던 PropertyEditor와는 달리 ConversionService라는 API를 제공한다. 작성이 간편하며 멀티스레드 환경에서 쓰기 용이하지만 단순히 컨테이너가 스프링 빈 값을 주입해야하는 상황이라면 PropertyEditor로도 충분하다.
```
<bean id="conversionService" // PropertyEditor 대신 사용된다.
  class="org.springframework.context.support.ConversionServiceFactoryBean">
  <property name="converters">
    <list>
      <bean class="springbook.converter.MyTypeConverter" />
    </list>
  </property>
</bean>
```
### 컬렉션
#### List, Set
```
<property name="names">
  <list>
    <value>element 1</value>
    <value>element 2</value>
  </list>
</property>
```
```
<property name="names">
  <set>
    <value>element 1</value>
    <value>element 2</value>
  </set>
</property>
```
#### Map
```
<property name="ages">
  <map>
    <entry key="element1" value="1" />
    <entry key="element2" value="2" />
  </map>
</property>
```
#### Properties
- 값/빈 레퍼런스 가능
```
<property name="settings">
  <props>
    <prop key="id">someUserId</prop>
    <prop key="pwd">someUserPwd</prop>
  </props>
</property>
```
```
<property name="settings">
  <list>
    <ref bean="beanA" />
    <ref bean="beanB" />
  </list>
</property>
```
- 컬렉션 사용 시 가능한 한 타입 파라미터를 제공해서 컨테이너가 타입 변환을 할 수 있도록 해주는 것이 좋다.
- 같은 타입의 모든 빈을 컬렉션으로 만들 때는 XML 대신 @Autowired와 컬랙션 타입의 프로퍼티를 이용하는 것이 좋다.

- util 스키마의 전용 태그를 이용하면 컬렉션을 프로퍼티 대신 빈으로 만들 수 있다.
#### <util:list>, <util:set>
```
<util:list name="names" list-class="java.util.LinkedList">
  <value>element 1</value>
  <value>element 2</value>
</util:list>
```
#### <util:map>
```
<util:map id="ages" map-class="java.util.TreeMap">
  <entry key="element1" value="1" />
  <entry key="element2" value="2" />
</util:map>
```
#### <util:properties>
```
<util:properties id="settings">
  <prop key="id">someUserId</prop>
  <prop key="pwd">someUserPwd</prop>
</util:properties>
```
### Null과 문자열
- Null과 ""은 다르다. 
- Null을 표현하고자 할 때는 <null /> 태그를 사용하면 된다.
- 예제) <property name="name"><null /></property>
### 프로퍼티 파일을 이용한 값 설정
- XML에서 일부 설정 정보를 별도 파일로 분리하면 유용할 수 있다.
- 어떤 설정 값들이 서로 변경되는 이유와 시점이 다르다면 분리해줄 필요가 있다.
- 예로 1부에서 본 다음 코드를 분리해보자.
```
<bean id="dataSource" class="org.springframework.jdbc.dataSource.SimpleDriverDataSource">
<property name="driverClass" value="com.mysql.jdbc.Driver" />
<property name="url" value="jdbc:mysql://localhost:testdb" />
<property name="username" value="spring" />
<property name="password" value="book" />
</bean>
```
- 먼저, 다음과 같이 내용을 properties 파일로 추출한다.
```
db.driverclass=com.mysql.jdbc.Driver
db.url=jdbc:mysql://localhost:testdb
db.username=spring
db.password=book
```
#### 수동 변환: ProerptyPlaceHolderConfigurer
- 기존 dataSource 관련 XML을 다음과 같이 바꿔준다.
```
<bean id="dataSource" class="org.springframework.jdbc.dataSource.SimpleDriverDataSource">
  <property name="driverClass" value="${db.driverClass}" />
  <property name="url" value="${db.url}" />
  <property name="username" value="${db.username}" />
  <property name="password" value="${db.password}" />
</bean>
```
- 그리고 <context:property-placeholder location="classpath:database.properties" />라고 추가하면 된다.
- PropertyPlaceHolderConfigurer라는 빈 팩토리 후처리기 빈이 값을 찾는대로 치환한다.
- 치환할 값을 못 찾을 시에는 ${}로 입력한 값이 그대로 남아있게 된다.
#### 능동 변환: SpEL(Spring Expression Language)
- 스프링 3.0에서 소개된 전용 표현식이다.
- #{} 표기법을 써서 프로퍼티를 불러온다.
```
<bean id="hello" ...>
  <property name="name" value="Spring" />
</bean>
<bean id="names">
  <property name="helloname" value="#{hello.name}" />
</bean>
```
- dataSource를 예로 들면 다음과 같이 적용할 수 있다.
```
<util:properties id="dbprops" location="classpath:databse.properties">
```
```
<bean id="dataSource" class="org.springframework.jdbc.dataSource.SimpleDriverDataSource">
  <property name="driverClass" value="#{dbprops['db.driverclass']}" />
  <property name="url" value="#{dbprops['db.url']}" />
  <property name="username" value="#{dbprops['db.username']}" />
  <property name="password" value="#{dbprops['db.password']}" />
</bean>
```
- 이 방법 또한 값을 못 찾을 경우 #{}로 입력한 값이 그대로 남아있게 된다.


## 1.2.5 컨테이너가 자동등록하는 빈

### ApplicationContext, BeanFactory
- ApplicationContext는 ApplicationContext 인터페이스를 구현한 것이며 다음과 같이 @Autowired로 DI 해줄 수 있다.
```
public class SystemBean {
@Autowired ApplicationContext context;

public void specialJobWithContext() {
  this.context.getBean(...);
}
...
}
```
- 애노테이션을 이용한 의존 관계 설정을 사용하지 않으면 @Autowired를 이용할 수 없는 이럴 때는 ApplicationContextAware라는 인터페이스의 setApplicationContext() 메소드를 이용하면 DI가 가능하다.
- 또, ApplicationContext는 BeanFactory를 상속하고 있다. 그래서 별도로 BeanFactory를 따로 DI할 필요가 없었다.
- 만약 별도로 BeanFactory 조작이 필요하다면 BeanFactoryAware 인터페이스를 구현하여 사용하면 된다.

### ResourceLoader, ApplicationEventPublisher
- 스프링 컨테이너는 ResourceLoader이기도 하다.
- 다음과 같이 ResourceLoader를 DI 할 수 있다.
```
@Autowired ResourceLoader resourceLoader;

public void loadDataFile() {
Resource resource = this.resourceLoader.getResource("WEB-INF/info.dat");
...
}
```
- ApplicationContext는 이 또한 상속하고 있다. 하지만 단순히 리소스를 읽어오는 것이 목적이라면 인터페이스 구현으로 대체해도 된다.
- ApplicationEventPublisher는 ApplicationListener 인터페이스를 구현한 빈에게 이벤트를 발생시킬 수 있는 publishEvent() 메소드를 가진 인터페이스다.
- 빈 사이의 독자적인 이벤트/리스너 구성하면 충분하기 때문에 굳이 사용 안해도 된다.

### systemProperties, systemEnvironment
- 각각 map과 properties 타입이기 때문에 이름을 통해 접근할 수 있다.
- systemProperties 빈은 System.getProperties() 메소드가 돌려주는 Properties 타입의 오브젝트를 읽기전용으로 접근할 수 있게 해주는 오브젝트다.
- 코드 상에서는 System.getProperty("os.name")처럼 이용하는게 낫지만 스프링 빈에서 프로퍼티로 넣는 경우에는 다음과 같이 systemProperties 빈을 이용하면 편하다.
```
@Resource Properties systemProperties;
```
```
@Value("#{systemProperties['os.name']}") String osName;
```
- systemEnvironment는 System.getenv()에서 제공하는 환경변수가 담긴 Map 오브젝트다.
- OS의 종류나 서버환경 설정에 따라 환경변수 이름이 바뀔 수 있으니 주의해야 한다.
```
@Value("#{systemEnvironment['Path']}") String path;
```
- systemProperties, systemEnvironment는 직접 정의할 경우 이 빈들을 자동으로 추가해주지 못하므로 사용을 최대한 자제하는 것이 좋다.
